#!/usr/bin/env ts-node

import { Command } from 'commander';
import { writeFile, access } from 'fs/promises';
import * as path from 'path';
import { constants } from 'fs';
import {
  parseConfig,
  processFiles,
  includeTypes,
  compressContent,
  createConfig,
  copyToClipboard,
} from './utils.ts';

const program = new Command();

program
  .name('genprompt')
  .description('Generate a prompt file based on project context')
  .version('1.0.0');

program
  .command('generate')
  .description('Generate the prompt file based on the configuration')
  .option('-c, --config <path>', 'Path to the config file', '.prompt.json')
  .option('-o, --output <path>', 'Output file (default: clipboard)')
  .option('--no-compress', 'Do not compress the content')
  .option('--include-all [pattern]', 'Include all files matching the pattern in the current directory and subdirectories')
  .option('-f, --files <patterns...>', 'Additional files or patterns to include')
  .action(async (options) => {
    const configPath = path.resolve(options.config);

    try {
      const config = await parseConfig(configPath);
      let content = '';

      content += `-- File generated by genprompt --config ${options.config}\n\n`;

      // Merge include files from config and command line
      let includeFiles = config.include || [];
      if (options.files) {
        includeFiles = includeFiles.concat(options.files);
      }

      if (options.includeAll) {
        const pattern = options.includeAll === true ? '**/*' : options.includeAll;
        includeFiles.push(pattern);
      }      

      if (config.includeFiles || options.files) {
        const filesContent = await processFiles(includeFiles);
        content += filesContent;
      }

      if (config.includeTypes) {
        const typesContent = await includeTypes(config.projectRoot || process.cwd());
        content += typesContent;
      }

      if (config.compress) {
        content = compressContent(content);
      }

      // Output to clipboard by default
      const outputPath = options.output ? path.resolve(options.output) : null;
      if (outputPath) {
        await writeFile(outputPath, content);
        console.log(`Prompt file generated at ${outputPath}`);
      } else {
        await copyToClipboard(content);
        console.log('Prompt copied to clipboard.');
      }
    } catch (error: any) {
      console.error('Error:', error.message);
    }
  });

program
  .command('init')
  .description('Create an initial .prompt.json configuration file')
  .option('-y, --yes', 'Accept all defaults and skip prompts')
  .option('-f, --force', 'Overwrite existing .prompt.json file')
  .action(async (options) => {
    const configPath = path.resolve('.prompt.json');

    try {
      if (!options.force) {
        // Check if .prompt.json already exists
        await access(configPath, constants.F_OK);
        console.error('.prompt.json already exists. Use --force to overwrite.');
        process.exit(1);
      }
    } catch {
      // File doesn't exist, proceed to create it
    }

    const config = await createConfig(!options.yes);
    await writeFile(configPath, JSON.stringify(config, null, 2));
    console.log(`Created initial .prompt.json at ${configPath}`);
  });

program.parse(process.argv);
